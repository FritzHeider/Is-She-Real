"""Lightweight fake-image detection helpers.

The functions in this module intentionally avoid heavyweight ML dependencies
and instead rely on heuristic metadata inspection and error-level analysis
(ELA). They provide a simple probability-style score that callers can display
in the UI alongside raw details such as suspicious metadata tags.
"""
from __future__ import annotations

from io import BytesIO
from typing import Any, Dict

import base64
import numpy as np
from PIL import Image, ImageChops, ImageEnhance, ImageOps, ExifTags

# Keywords that often appear in prompts or generator signatures.
SUSPICIOUS_KEYWORDS = [
    "stable",
    "diffusion",
    "sd-",
    "dall",
    "midjourney",
    "ai-generated",
    "generator",
    "artificial",
    "deviantart",
]

# Map EXIF tag IDs to human-readable names.
EXIF_TAG_MAP = {tag_id: tag_name for tag_id, tag_name in ExifTags.TAGS.items()}


def _max_from_extrema(extrema: Any) -> float:
    """Return the maximum value from Image.getextrema output."""

    if isinstance(extrema, (list, tuple)):
        vals = []
        for item in extrema:
            if isinstance(item, (list, tuple)):
                vals.append(max(item))
            else:
                vals.append(item)
        return float(max(vals) if vals else 0.0)
    return float(extrema or 0.0)


def analyze_metadata(img: Image.Image) -> Dict[str, Any]:
    """Inspect EXIF metadata for clues that the image was generated by AI."""

    result: Dict[str, Any] = {"has_exif": False, "suspicious_tags": [], "tag_count": 0}
    try:
        exif = img.getexif()
    except Exception:
        exif = None

    if exif:
        result["has_exif"] = True
        result["tag_count"] = len(exif.items())
        for tag_id, value in exif.items():
            text_value = str(value)
            lowered = text_value.lower()
            if any(keyword in lowered for keyword in SUSPICIOUS_KEYWORDS):
                tag_name = EXIF_TAG_MAP.get(tag_id, str(tag_id))
                result["suspicious_tags"].append(
                    {
                        "tag": tag_name,
                        "value": text_value[:500],
                    }
                )
    return result


def perform_ela(img: Image.Image, quality: int = 90) -> tuple[Image.Image, float]:
    """Perform Error Level Analysis and return (ELA image, mean difference).

    The mean difference is normalised to [0, 1]. Higher scores tend to
    correlate with manipulated regions.
    """

    buffer = BytesIO()
    img.save(buffer, format="JPEG", quality=quality)
    buffer.seek(0)
    with Image.open(buffer) as recompressed:
        recompressed = recompressed.convert("RGB")
        diff = ImageChops.difference(img, recompressed)

    extrema = diff.getextrema()
    max_diff = _max_from_extrema(extrema) or 1.0
    scale_factor = 255.0 / max_diff
    diff_enhanced = ImageEnhance.Brightness(diff).enhance(scale_factor)
    diff_enhanced = ImageOps.autocontrast(diff_enhanced)

    diff_np = np.array(diff_enhanced.convert("L"), dtype=np.float32)
    mean_diff = float(np.mean(diff_np) / 255.0)
    return diff_enhanced, mean_diff


def _image_to_data_url(image: Image.Image) -> str:
    buffer = BytesIO()
    image.convert("RGB").save(buffer, format="JPEG", quality=90)
    b64 = base64.b64encode(buffer.getvalue()).decode("ascii")
    return f"data:image/jpeg;base64,{b64}"


def detect_image_bytes(data: bytes) -> Dict[str, Any]:
    """Analyse image bytes and return scoring details."""

    if not data:
        raise ValueError("empty image payload")

    with Image.open(BytesIO(data)) as img:
        img = img.convert("RGB")
        metadata_info = analyze_metadata(img)
        ela_image, mean_ela = perform_ela(img)

    fake_score = min(1.0, mean_ela + (0.3 if metadata_info["suspicious_tags"] else 0.0))
    ela_preview = _image_to_data_url(ela_image) if ela_image else None
    if ela_image:
        ela_image.close()

    return {
        "fake_score": round(fake_score, 3),
        "mean_ela": round(mean_ela, 3),
        "metadata_info": metadata_info,
        "ela_preview": ela_preview,
    }
